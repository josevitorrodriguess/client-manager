// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: customer_queries.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addAddressToCustomer = `-- name: AddAddressToCustomer :one
INSERT INTO addresses (
    customer_id,
    address_type,
    street,
    number,
    complement,
    state,
    city,
    cep
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id
`

type AddAddressToCustomerParams struct {
	CustomerID  uuid.UUID   `json:"customer_id"`
	AddressType string      `json:"address_type"`
	Street      string      `json:"street"`
	Number      string      `json:"number"`
	Complement  pgtype.Text `json:"complement"`
	State       string      `json:"state"`
	City        string      `json:"city"`
	Cep         string      `json:"cep"`
}

func (q *Queries) AddAddressToCustomer(ctx context.Context, arg AddAddressToCustomerParams) (int32, error) {
	row := q.db.QueryRow(ctx, addAddressToCustomer,
		arg.CustomerID,
		arg.AddressType,
		arg.Street,
		arg.Number,
		arg.Complement,
		arg.State,
		arg.City,
		arg.Cep,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createCustomerPF = `-- name: CreateCustomerPF :one
WITH new_customer AS (
    INSERT INTO customers (type, email, phone)
    VALUES ($1, $2, $3)
    RETURNING id
),
customer_pf AS (
    INSERT INTO customerf_pf (customer_id, cpf, name, birth_date)
    SELECT id, $4, $5, $6
    FROM new_customer
    RETURNING customer_id
)
INSERT INTO addresses (
    customer_id,
    address_type,
    street,
    number,
    complement,
    state,
    city,
    cep
)
SELECT 
    customer_id,
    $7, $8, $9, $10, $11, $12, $13
FROM customer_pf
RETURNING customer_id
`

type CreateCustomerPFParams struct {
	Type        CustomerType `json:"type"`
	Email       string       `json:"email"`
	Phone       string       `json:"phone"`
	Cpf         string       `json:"cpf"`
	Name        string       `json:"name"`
	BirthDate   pgtype.Date  `json:"birth_date"`
	AddressType string       `json:"address_type"`
	Street      string       `json:"street"`
	Number      string       `json:"number"`
	Complement  pgtype.Text  `json:"complement"`
	State       string       `json:"state"`
	City        string       `json:"city"`
	Cep         string       `json:"cep"`
}

func (q *Queries) CreateCustomerPF(ctx context.Context, arg CreateCustomerPFParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createCustomerPF,
		arg.Type,
		arg.Email,
		arg.Phone,
		arg.Cpf,
		arg.Name,
		arg.BirthDate,
		arg.AddressType,
		arg.Street,
		arg.Number,
		arg.Complement,
		arg.State,
		arg.City,
		arg.Cep,
	)
	var customer_id uuid.UUID
	err := row.Scan(&customer_id)
	return customer_id, err
}

const createCustomerPJ = `-- name: CreateCustomerPJ :one
WITH new_customer AS (
    INSERT INTO customers (type, email, phone)
    VALUES ($1, $2, $3)
    RETURNING id
),
customer_pj AS (
    INSERT INTO customerf_pj (customer_id, cnpj, company_name)
    SELECT id, $4, $5
    FROM new_customer
    RETURNING customer_id
)
INSERT INTO addresses (
    customer_id,
    address_type,
    street,
    number,
    complement,
    state,
    city,
    cep
)
SELECT 
    customer_id,
    $6, $7, $8, $9, $10, $11, $12
FROM customer_pj
RETURNING customer_id
`

type CreateCustomerPJParams struct {
	Type        CustomerType `json:"type"`
	Email       string       `json:"email"`
	Phone       string       `json:"phone"`
	Cnpj        string       `json:"cnpj"`
	CompanyName string       `json:"company_name"`
	AddressType string       `json:"address_type"`
	Street      string       `json:"street"`
	Number      string       `json:"number"`
	Complement  pgtype.Text  `json:"complement"`
	State       string       `json:"state"`
	City        string       `json:"city"`
	Cep         string       `json:"cep"`
}

func (q *Queries) CreateCustomerPJ(ctx context.Context, arg CreateCustomerPJParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createCustomerPJ,
		arg.Type,
		arg.Email,
		arg.Phone,
		arg.Cnpj,
		arg.CompanyName,
		arg.AddressType,
		arg.Street,
		arg.Number,
		arg.Complement,
		arg.State,
		arg.City,
		arg.Cep,
	)
	var customer_id uuid.UUID
	err := row.Scan(&customer_id)
	return customer_id, err
}

const deleteAddress = `-- name: DeleteAddress :exec
DELETE FROM addresses
WHERE id = $1
`

func (q *Queries) DeleteAddress(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteAddress, id)
	return err
}

const deleteCustomer = `-- name: DeleteCustomer :exec
DELETE FROM customers
WHERE id = $1
`

func (q *Queries) DeleteCustomer(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCustomer, id)
	return err
}

const getAllCustomers = `-- name: GetAllCustomers :many
SELECT
    c.id AS customer_id,
    c.email AS customer_email,
    c.phone AS customer_phone,
    c.created_at AS customer_created_at,
    c.updated_at AS customer_updated_at,
    c.is_active AS customer_is_active,

    pf.cpf AS pf_cpf,
    pf.name AS pf_name,
    pf.birth_date AS pf_birth_date,

    pj.cnpj AS pj_cnpj,
    pj.company_name AS pj_company_name,

    COALESCE(
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'address_id', a.id,
                'address_type', a.address_type,
                'street', a.street,
                'number', a.number,
                'complement', a.complement,
                'state', a.state,
                'city', a.city,
                'cep', a.cep
            )
        ) FILTER (WHERE a.id IS NOT NULL),
        '[]'
    ) AS addresses
FROM customers c
LEFT JOIN customerf_pf pf ON c.id = pf.customer_id
LEFT JOIN customerf_pj pj ON c.id = pj.customer_id
LEFT JOIN addresses a ON c.id = a.customer_id
GROUP BY 
    c.id, c.email, c.phone, c.created_at, c.updated_at, c.is_active,
    pf.cpf, pf.name, pf.birth_date,
    pj.cnpj, pj.company_name
ORDER BY c.id
`

type GetAllCustomersRow struct {
	CustomerID        uuid.UUID          `json:"customer_id"`
	CustomerEmail     string             `json:"customer_email"`
	CustomerPhone     string             `json:"customer_phone"`
	CustomerCreatedAt pgtype.Timestamptz `json:"customer_created_at"`
	CustomerUpdatedAt pgtype.Timestamptz `json:"customer_updated_at"`
	CustomerIsActive  bool               `json:"customer_is_active"`
	PfCpf             pgtype.Text        `json:"pf_cpf"`
	PfName            pgtype.Text        `json:"pf_name"`
	PfBirthDate       pgtype.Date        `json:"pf_birth_date"`
	PjCnpj            pgtype.Text        `json:"pj_cnpj"`
	PjCompanyName     pgtype.Text        `json:"pj_company_name"`
	Addresses         interface{}        `json:"addresses"`
}


func (q *Queries) GetAllCustomers(ctx context.Context) ([]GetAllCustomersRow, error) {
	rows, err := q.db.Query(ctx, getAllCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCustomersRow
	for rows.Next() {
		var i GetAllCustomersRow
		if err := rows.Scan(
			&i.CustomerID,
			&i.CustomerEmail,
			&i.CustomerPhone,
			&i.CustomerCreatedAt,
			&i.CustomerUpdatedAt,
			&i.CustomerIsActive,
			&i.PfCpf,
			&i.PfName,
			&i.PfBirthDate,
			&i.PjCnpj,
			&i.PjCompanyName,
			&i.Addresses,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerAddresses = `-- name: GetCustomerAddresses :many
SELECT 
    id,
    address_type,
    street,
    number,
    complement,
    state,
    city,
    cep
FROM addresses
WHERE customer_id = $1
`

type GetCustomerAddressesRow struct {
	ID          int32       `json:"id"`
	AddressType string      `json:"address_type"`
	Street      string      `json:"street"`
	Number      string      `json:"number"`
	Complement  pgtype.Text `json:"complement"`
	State       string      `json:"state"`
	City        string      `json:"city"`
	Cep         string      `json:"cep"`
}

func (q *Queries) GetCustomerAddresses(ctx context.Context, customerID uuid.UUID) ([]GetCustomerAddressesRow, error) {
	rows, err := q.db.Query(ctx, getCustomerAddresses, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCustomerAddressesRow
	for rows.Next() {
		var i GetCustomerAddressesRow
		if err := rows.Scan(
			&i.ID,
			&i.AddressType,
			&i.Street,
			&i.Number,
			&i.Complement,
			&i.State,
			&i.City,
			&i.Cep,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerByID = `-- name: GetCustomerByID :one
SELECT 
    c.id,
    c.type,
    c.email,
    c.phone,
    c.is_active,
    c.created_at,
    c.updated_at,
    CASE 
        WHEN c.type = 'PF' THEN pf.cpf
        ELSE NULL
    END as cpf,
    CASE 
        WHEN c.type = 'PF' THEN pf.name
        ELSE NULL
    END as pf_name,
    CASE 
        WHEN c.type = 'PF' THEN pf.birth_date
        ELSE NULL
    END as birth_date,
    CASE 
        WHEN c.type = 'PJ' THEN pj.cnpj
        ELSE NULL
    END as cnpj,
    CASE 
        WHEN c.type = 'PJ' THEN pj.company_name
        ELSE NULL
    END as company_name
FROM customers c
LEFT JOIN customerf_pf pf ON c.id = pf.customer_id AND c.type = 'PF'
LEFT JOIN customerf_pj pj ON c.id = pj.customer_id AND c.type = 'PJ'
WHERE c.id = $1
`

type GetCustomerByIDRow struct {
	ID          uuid.UUID          `json:"id"`
	Type        CustomerType       `json:"type"`
	Email       string             `json:"email"`
	Phone       string             `json:"phone"`
	IsActive    bool               `json:"is_active"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	Cpf         interface{}        `json:"cpf"`
	PfName      interface{}        `json:"pf_name"`
	BirthDate   interface{}        `json:"birth_date"`
	Cnpj        interface{}        `json:"cnpj"`
	CompanyName interface{}        `json:"company_name"`
}

func (q *Queries) GetCustomerByID(ctx context.Context, id uuid.UUID) (GetCustomerByIDRow, error) {
	row := q.db.QueryRow(ctx, getCustomerByID, id)
	var i GetCustomerByIDRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Email,
		&i.Phone,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cpf,
		&i.PfName,
		&i.BirthDate,
		&i.Cnpj,
		&i.CompanyName,
	)
	return i, err
}

const updateAddress = `-- name: UpdateAddress :one
UPDATE addresses
SET 
    address_type = $2,
    street = $3,
    number = $4,
    complement = $5,
    state = $6,
    city = $7,
    cep = $8
WHERE id = $1
RETURNING id
`

type UpdateAddressParams struct {
	ID          int32       `json:"id"`
	AddressType string      `json:"address_type"`
	Street      string      `json:"street"`
	Number      string      `json:"number"`
	Complement  pgtype.Text `json:"complement"`
	State       string      `json:"state"`
	City        string      `json:"city"`
	Cep         string      `json:"cep"`
}

func (q *Queries) UpdateAddress(ctx context.Context, arg UpdateAddressParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateAddress,
		arg.ID,
		arg.AddressType,
		arg.Street,
		arg.Number,
		arg.Complement,
		arg.State,
		arg.City,
		arg.Cep,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateCustomerBasicInfo = `-- name: UpdateCustomerBasicInfo :one
UPDATE customers
SET email = $2, phone = $3
WHERE id = $1
RETURNING id
`

type UpdateCustomerBasicInfoParams struct {
	ID    uuid.UUID `json:"id"`
	Email string    `json:"email"`
	Phone string    `json:"phone"`
}

func (q *Queries) UpdateCustomerBasicInfo(ctx context.Context, arg UpdateCustomerBasicInfoParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, updateCustomerBasicInfo, arg.ID, arg.Email, arg.Phone)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
