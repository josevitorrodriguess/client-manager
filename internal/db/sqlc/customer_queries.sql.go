// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: customer_queries.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addAddressToCustomer = `-- name: AddAddressToCustomer :one
INSERT INTO addresses (
    customer_id,
    address_type,
    street,
    number,
    complement,
    state,
    city,
    cep
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id
`

type AddAddressToCustomerParams struct {
	CustomerID  uuid.UUID   `json:"customer_id"`
	AddressType string      `json:"address_type"`
	Street      string      `json:"street"`
	Number      string      `json:"number"`
	Complement  pgtype.Text `json:"complement"`
	State       string      `json:"state"`
	City        string      `json:"city"`
	Cep         string      `json:"cep"`
}

func (q *Queries) AddAddressToCustomer(ctx context.Context, arg AddAddressToCustomerParams) (int32, error) {
	row := q.db.QueryRow(ctx, addAddressToCustomer,
		arg.CustomerID,
		arg.AddressType,
		arg.Street,
		arg.Number,
		arg.Complement,
		arg.State,
		arg.City,
		arg.Cep,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
} 

const createCustomerPF = `-- name: CreateCustomerPF :one
WITH new_customer AS (
    INSERT INTO customers (type, email, phone)
    VALUES ($1, $2, $3)
    RETURNING id
),
customer_pf AS (
    INSERT INTO customerf_pf (customer_id, cpf, name, birth_date)
    SELECT id, $4, $5, $6
    FROM new_customer
    RETURNING customer_id
)
INSERT INTO addresses (
    customer_id,
    address_type,
    street,
    number,
    complement,
    state,
    city,
    cep
)
SELECT 
    customer_id,
    $7, $8, $9, $10, $11, $12, $13
FROM customer_pf
RETURNING customer_id
`

type CreateCustomerPFParams struct {
	Type        CustomerType `json:"type"`
	Email       string       `json:"email"`
	Phone       string       `json:"phone"`
	Cpf         string       `json:"cpf"`
	Name        string       `json:"name"`
	BirthDate   pgtype.Date  `json:"birth_date"`
	AddressType string       `json:"address_type"`
	Street      string       `json:"street"`
	Number      string       `json:"number"`
	Complement  pgtype.Text  `json:"complement"`
	State       string       `json:"state"`
	City        string       `json:"city"`
	Cep         string       `json:"cep"`
}

func (q *Queries) CreateCustomerPF(ctx context.Context, arg CreateCustomerPFParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createCustomerPF,
		arg.Type,
		arg.Email,
		arg.Phone,
		arg.Cpf,
		arg.Name,
		arg.BirthDate,
		arg.AddressType,
		arg.Street,
		arg.Number,
		arg.Complement,
		arg.State,
		arg.City,
		arg.Cep,
	)
	var customer_id uuid.UUID
	err := row.Scan(&customer_id)
	return customer_id, err
}

const createCustomerPJ = `-- name: CreateCustomerPJ :one
WITH new_customer AS (
    INSERT INTO customers (type, email, phone)
    VALUES ($1, $2, $3)
    RETURNING id
),
customer_pj AS (
    INSERT INTO customerf_pj (customer_id, cnpj, company_name)
    SELECT id, $4, $5
    FROM new_customer
    RETURNING customer_id
)
INSERT INTO addresses (
    customer_id,
    address_type,
    street,
    number,
    complement,
    state,
    city,
    cep
)
SELECT 
    customer_id,
    $6, $7, $8, $9, $10, $11, $12
FROM customer_pj
RETURNING customer_id
`

type CreateCustomerPJParams struct {
	Type        CustomerType `json:"type"`
	Email       string       `json:"email"`
	Phone       string       `json:"phone"`
	Cnpj        string       `json:"cnpj"`
	CompanyName string       `json:"company_name"`
	AddressType string       `json:"address_type"`
	Street      string       `json:"street"`
	Number      string       `json:"number"`
	Complement  pgtype.Text  `json:"complement"`
	State       string       `json:"state"`
	City        string       `json:"city"`
	Cep         string       `json:"cep"`
}

func (q *Queries) CreateCustomerPJ(ctx context.Context, arg CreateCustomerPJParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createCustomerPJ,
		arg.Type,
		arg.Email,
		arg.Phone,
		arg.Cnpj,
		arg.CompanyName,
		arg.AddressType,
		arg.Street,
		arg.Number,
		arg.Complement,
		arg.State,
		arg.City,
		arg.Cep,
	)
	var customer_id uuid.UUID
	err := row.Scan(&customer_id)
	return customer_id, err
}

const deleteAddress = `-- name: DeleteAddress :exec
DELETE FROM addresses
WHERE id = $1
`

func (q *Queries) DeleteAddress(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteAddress, id)
	return err
}

const deleteCustomer = `-- name: DeleteCustomer :exec


DELETE FROM customers
WHERE id = $1
`

// -- name: UpdateCustomer :one
// UPDATE customers
// SET email = $2, phone = $3
// WHERE id = $1
// RETURNING id, email, phone;
func (q *Queries) DeleteCustomer(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCustomer, id)
	return err
}

const getAllCustomers = `-- name: GetAllCustomers :many
SELECT id, type, email, phone, created_at, updated_at, is_active FROM customers
`

func (q *Queries) GetAllCustomers(ctx context.Context) ([]Customer, error) {
	rows, err := q.db.Query(ctx, getAllCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Email,
			&i.Phone,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerAddresses = `-- name: GetCustomerAddresses :many
SELECT id, customer_id, address_type, street, number, complement, state, city, cep FROM addresses
WHERE customer_id = $1
`

func (q *Queries) GetCustomerAddresses(ctx context.Context, customerID uuid.UUID) ([]Address, error) {
	rows, err := q.db.Query(ctx, getCustomerAddresses, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Address
	for rows.Next() {
		var i Address
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.AddressType,
			&i.Street,
			&i.Number,
			&i.Complement,
			&i.State,
			&i.City,
			&i.Cep,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerByEmail = `-- name: GetCustomerByEmail :one
SELECT id, type, email, phone, created_at, updated_at, is_active FROM customers
WHERE email = $1
`

func (q *Queries) GetCustomerByEmail(ctx context.Context, email string) (Customer, error) {
	row := q.db.QueryRow(ctx, getCustomerByEmail, email)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Email,
		&i.Phone,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
	)
	return i, err
}

const getCustomerByID = `-- name: GetCustomerByID :one
SELECT id, type, email, phone, created_at, updated_at, is_active FROM customers
WHERE id = $1
`

func (q *Queries) GetCustomerByID(ctx context.Context, id uuid.UUID) (Customer, error) {
	row := q.db.QueryRow(ctx, getCustomerByID, id)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Email,
		&i.Phone,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
	)
	return i, err
}

const getCustomerPFDetails = `-- name: GetCustomerPFDetails :one
SELECT 
    c.id,
    c.email,
    c.phone,
    c.created_at,
    c.updated_at,
    c.is_active,
    pf.cpf,
    pf.name,
    pf.birth_date
FROM customers c
JOIN customerf_pf pf ON c.id = pf.customer_id
WHERE c.id = $1
`

type GetCustomerPFDetailsRow struct {
	ID        uuid.UUID          `json:"id"`
	Email     string             `json:"email"`
	Phone     string             `json:"phone"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	IsActive  bool               `json:"is_active"`
	Cpf       string             `json:"cpf"`
	Name      string             `json:"name"`
	BirthDate pgtype.Date        `json:"birth_date"`
}

func (q *Queries) GetCustomerPFDetails(ctx context.Context, id uuid.UUID) (GetCustomerPFDetailsRow, error) {
	row := q.db.QueryRow(ctx, getCustomerPFDetails, id)
	var i GetCustomerPFDetailsRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
		&i.Cpf,
		&i.Name,
		&i.BirthDate,
	)
	return i, err
}

const getCustomerPJDetails = `-- name: GetCustomerPJDetails :one
SELECT 
    c.id,
    c.email,
    c.phone,
    c.created_at,
    c.updated_at,
    c.is_active,
    pj.cnpj,
    pj.company_name
FROM customers c
JOIN customerf_pj pj ON c.id = pj.customer_id
WHERE c.id = $1
`

type GetCustomerPJDetailsRow struct {
	ID          uuid.UUID          `json:"id"`
	Email       string             `json:"email"`
	Phone       string             `json:"phone"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	IsActive    bool               `json:"is_active"`
	Cnpj        string             `json:"cnpj"`
	CompanyName string             `json:"company_name"`
}

func (q *Queries) GetCustomerPJDetails(ctx context.Context, id uuid.UUID) (GetCustomerPJDetailsRow, error) {
	row := q.db.QueryRow(ctx, getCustomerPJDetails, id)
	var i GetCustomerPJDetailsRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
		&i.Cnpj,
		&i.CompanyName,
	)
	return i, err
}

const getRecentCustomers = `-- name: GetRecentCustomers :many
SELECT id, type, email, phone, created_at, updated_at, is_active FROM customers
ORDER BY created_at DESC
LIMIT $1
`

func (q *Queries) GetRecentCustomers(ctx context.Context, limit int32) ([]Customer, error) {
	rows, err := q.db.Query(ctx, getRecentCustomers, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Email,
			&i.Phone,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveCustomers = `-- name: ListActiveCustomers :many
SELECT id, type, email, phone, created_at, updated_at, is_active FROM customers
WHERE is_active = true
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListActiveCustomersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListActiveCustomers(ctx context.Context, arg ListActiveCustomersParams) ([]Customer, error) {
	rows, err := q.db.Query(ctx, listActiveCustomers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Email,
			&i.Phone,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCustomersByEmail = `-- name: SearchCustomersByEmail :many
SELECT id, type, email, phone, created_at, updated_at, is_active FROM customers
WHERE email ILIKE $1
LIMIT $2
`

type SearchCustomersByEmailParams struct {
	Email string `json:"email"`
	Limit int32  `json:"limit"`
}

func (q *Queries) SearchCustomersByEmail(ctx context.Context, arg SearchCustomersByEmailParams) ([]Customer, error) {
	rows, err := q.db.Query(ctx, searchCustomersByEmail, arg.Email, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Email,
			&i.Phone,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPFCustomersByName = `-- name: SearchPFCustomersByName :many
SELECT c.id, c.type, c.email, c.phone, c.created_at, c.updated_at, c.is_active FROM customers c
JOIN customerf_pf pf ON c.id = pf.customer_id
WHERE pf.name ILIKE $1
LIMIT $2
`

type SearchPFCustomersByNameParams struct {
	Name  string `json:"name"`
	Limit int32  `json:"limit"`
}

func (q *Queries) SearchPFCustomersByName(ctx context.Context, arg SearchPFCustomersByNameParams) ([]Customer, error) {
	rows, err := q.db.Query(ctx, searchPFCustomersByName, arg.Name, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Email,
			&i.Phone,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPJCustomersByCompanyName = `-- name: SearchPJCustomersByCompanyName :many
SELECT c.id, c.type, c.email, c.phone, c.created_at, c.updated_at, c.is_active FROM customers c
JOIN customerf_pj pj ON c.id = pj.customer_id
WHERE pj.company_name ILIKE $1
LIMIT $2
`

type SearchPJCustomersByCompanyNameParams struct {
	CompanyName string `json:"company_name"`
	Limit       int32  `json:"limit"`
}

func (q *Queries) SearchPJCustomersByCompanyName(ctx context.Context, arg SearchPJCustomersByCompanyNameParams) ([]Customer, error) {
	rows, err := q.db.Query(ctx, searchPJCustomersByCompanyName, arg.CompanyName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Email,
			&i.Phone,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setCustomerStatus = `-- name: SetCustomerStatus :exec
UPDATE customers
SET is_active = $2
WHERE id = $1
`

type SetCustomerStatusParams struct {
	ID       uuid.UUID `json:"id"`
	IsActive bool      `json:"is_active"`
}

func (q *Queries) SetCustomerStatus(ctx context.Context, arg SetCustomerStatusParams) error {
	_, err := q.db.Exec(ctx, setCustomerStatus, arg.ID, arg.IsActive)
	return err
}

const updateAddress = `-- name: UpdateAddress :one
UPDATE addresses
SET 
    address_type = $2,
    street = $3,
    number = $4,
    complement = $5,
    state = $6,
    city = $7,
    cep = $8
WHERE id = $1
RETURNING id
`

type UpdateAddressParams struct {
	ID          int32       `json:"id"`
	AddressType string      `json:"address_type"`
	Street      string      `json:"street"`
	Number      string      `json:"number"`
	Complement  pgtype.Text `json:"complement"`
	State       string      `json:"state"`
	City        string      `json:"city"`
	Cep         string      `json:"cep"`
}

func (q *Queries) UpdateAddress(ctx context.Context, arg UpdateAddressParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateAddress,
		arg.ID,
		arg.AddressType,
		arg.Street,
		arg.Number,
		arg.Complement,
		arg.State,
		arg.City,
		arg.Cep,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateCustomerBasicInfo = `-- name: UpdateCustomerBasicInfo :one
UPDATE customers
SET email = $2, phone = $3
WHERE id = $1
RETURNING id
`

type UpdateCustomerBasicInfoParams struct {
	ID    uuid.UUID `json:"id"`
	Email string    `json:"email"`
	Phone string    `json:"phone"`
}

func (q *Queries) UpdateCustomerBasicInfo(ctx context.Context, arg UpdateCustomerBasicInfoParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, updateCustomerBasicInfo, arg.ID, arg.Email, arg.Phone)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const updateCustomerPF = `-- name: UpdateCustomerPF :one
UPDATE customerf_pf
SET name = $2, cpf = $3, birth_date = $4
WHERE customer_id = $1
RETURNING customer_id
`

type UpdateCustomerPFParams struct {
	CustomerID uuid.UUID   `json:"customer_id"`
	Name       string      `json:"name"`
	Cpf        string      `json:"cpf"`
	BirthDate  pgtype.Date `json:"birth_date"`
}

func (q *Queries) UpdateCustomerPF(ctx context.Context, arg UpdateCustomerPFParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, updateCustomerPF,
		arg.CustomerID,
		arg.Name,
		arg.Cpf,
		arg.BirthDate,
	)
	var customer_id uuid.UUID
	err := row.Scan(&customer_id)
	return customer_id, err
}

const updateCustomerPJ = `-- name: UpdateCustomerPJ :one
UPDATE customerf_pj
SET company_name = $2, cnpj = $3
WHERE customer_id = $1
RETURNING customer_id
`

type UpdateCustomerPJParams struct {
	CustomerID  uuid.UUID `json:"customer_id"`
	CompanyName string    `json:"company_name"`
	Cnpj        string    `json:"cnpj"`
}

func (q *Queries) UpdateCustomerPJ(ctx context.Context, arg UpdateCustomerPJParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, updateCustomerPJ, arg.CustomerID, arg.CompanyName, arg.Cnpj)
	var customer_id uuid.UUID
	err := row.Scan(&customer_id)
	return customer_id, err
}
