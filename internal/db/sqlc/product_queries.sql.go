// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: product_queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countProductsByCustomerID = `-- name: CountProductsByCustomerID :one
SELECT COUNT(*) FROM products
WHERE customer_id = $1
`

func (q *Queries) CountProductsByCustomerID(ctx context.Context, customerID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countProductsByCustomerID, customerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products
WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteProduct, id)
	return err
}

const getProductByID = `-- name: GetProductByID :one
SELECT id, customer_id, type_product, description, total_value, down_payment, is_paid, is_finished FROM products
WHERE id = $1
`

func (q *Queries) GetProductByID(ctx context.Context, id int32) (Product, error) {
	row := q.db.QueryRow(ctx, getProductByID, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.TypeProduct,
		&i.Description,
		&i.TotalValue,
		&i.DownPayment,
		&i.IsPaid,
		&i.IsFinished,
	)
	return i, err
}

const getProductsByCustomerID = `-- name: GetProductsByCustomerID :many
SELECT id, customer_id, type_product, description, total_value, down_payment, is_paid, is_finished FROM products
WHERE customer_id = $1
ORDER BY id
`

func (q *Queries) GetProductsByCustomerID(ctx context.Context, customerID pgtype.UUID) ([]Product, error) {
	rows, err := q.db.Query(ctx, getProductsByCustomerID, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.TypeProduct,
			&i.Description,
			&i.TotalValue,
			&i.DownPayment,
			&i.IsPaid,
			&i.IsFinished,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsValueSumByCustomerID = `-- name: GetProductsValueSumByCustomerID :one
SELECT SUM(total_value) FROM products
WHERE customer_id = $1
`

func (q *Queries) GetProductsValueSumByCustomerID(ctx context.Context, customerID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getProductsValueSumByCustomerID, customerID)
	var sum int64
	err := row.Scan(&sum)
	return sum, err
}

const getUnfinishedProductsByCustomerID = `-- name: GetUnfinishedProductsByCustomerID :many
SELECT id, customer_id, type_product, description, total_value, down_payment, is_paid, is_finished FROM products
WHERE customer_id = $1 AND is_finished = false
ORDER BY id
`

func (q *Queries) GetUnfinishedProductsByCustomerID(ctx context.Context, customerID pgtype.UUID) ([]Product, error) {
	rows, err := q.db.Query(ctx, getUnfinishedProductsByCustomerID, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.TypeProduct,
			&i.Description,
			&i.TotalValue,
			&i.DownPayment,
			&i.IsPaid,
			&i.IsFinished,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnpaidProductsByCustomerID = `-- name: GetUnpaidProductsByCustomerID :many
SELECT 
    id,
    customer_id,
    type_product,
    description,
    total_value,
    down_payment,
    is_paid,
    is_finished,
    (total_value - down_payment) AS remaining_to_pay
FROM products
WHERE customer_id = $1 AND is_paid = false
ORDER BY id
`

type GetUnpaidProductsByCustomerIDRow struct {
	ID             int32          `json:"id"`
	CustomerID     pgtype.UUID    `json:"customer_id"`
	TypeProduct    string         `json:"type_product"`
	Description    string         `json:"description"`
	TotalValue     pgtype.Numeric `json:"total_value"`
	DownPayment    pgtype.Numeric `json:"down_payment"`
	IsPaid         pgtype.Bool    `json:"is_paid"`
	IsFinished     pgtype.Bool    `json:"is_finished"`
	RemainingToPay int32          `json:"remaining_to_pay"`
}

func (q *Queries) GetUnpaidProductsByCustomerID(ctx context.Context, customerID pgtype.UUID) ([]GetUnpaidProductsByCustomerIDRow, error) {
	rows, err := q.db.Query(ctx, getUnpaidProductsByCustomerID, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnpaidProductsByCustomerIDRow
	for rows.Next() {
		var i GetUnpaidProductsByCustomerIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.TypeProduct,
			&i.Description,
			&i.TotalValue,
			&i.DownPayment,
			&i.IsPaid,
			&i.IsFinished,
			&i.RemainingToPay,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllProducts = `-- name: ListAllProducts :many
SELECT id, customer_id, type_product, description, total_value, down_payment, is_paid, is_finished FROM products
ORDER BY id
`

func (q *Queries) ListAllProducts(ctx context.Context) ([]Product, error) {
	rows, err := q.db.Query(ctx, listAllProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.TypeProduct,
			&i.Description,
			&i.TotalValue,
			&i.DownPayment,
			&i.IsPaid,
			&i.IsFinished,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProductFinishStatus = `-- name: UpdateProductFinishStatus :one
UPDATE products
SET is_finished = $1
WHERE id = $2
RETURNING id, customer_id, type_product, description, total_value, down_payment, is_paid, is_finished
`

type UpdateProductFinishStatusParams struct {
	IsFinished pgtype.Bool `json:"is_finished"`
	ID         int32       `json:"id"`
}

func (q *Queries) UpdateProductFinishStatus(ctx context.Context, arg UpdateProductFinishStatusParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProductFinishStatus, arg.IsFinished, arg.ID)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.TypeProduct,
		&i.Description,
		&i.TotalValue,
		&i.DownPayment,
		&i.IsPaid,
		&i.IsFinished,
	)
	return i, err
}

const updateProductPaymentStatus = `-- name: UpdateProductPaymentStatus :one
UPDATE products
SET is_paid = $1
WHERE id = $2
RETURNING id, customer_id, type_product, description, total_value, down_payment, is_paid, is_finished
`

type UpdateProductPaymentStatusParams struct {
	IsPaid pgtype.Bool `json:"is_paid"`
	ID     int32       `json:"id"`
}

func (q *Queries) UpdateProductPaymentStatus(ctx context.Context, arg UpdateProductPaymentStatusParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProductPaymentStatus, arg.IsPaid, arg.ID)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.TypeProduct,
		&i.Description,
		&i.TotalValue,
		&i.DownPayment,
		&i.IsPaid,
		&i.IsFinished,
	)
	return i, err
}
